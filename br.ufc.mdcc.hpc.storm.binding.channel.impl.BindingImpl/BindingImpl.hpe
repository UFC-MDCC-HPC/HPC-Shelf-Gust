<?xml version="1.0" encoding="ASCII"?>
<component:component xmlns:component="http://www.example.org/HashComponent">
  <header hash_component_UID="0024000004800000940000000602000000240000525341310004000011000000d3f4d66810b315a3fba3414140ef24527df54bf594d16386a7d5633ec519f0650b5c8fc379399edb80dceb62968ee7a20a8b958cb70e7d17209624755e1fd02c308d7539d2d925bee692172909d8eeb1f20d998cc5f4a6dcff977007a877da97cb245bd805331b08dc4924a82b5058fc53d65299acda9946697b18ac8c7e02e3" isAbstract="false" kind="Binding" name="BindingImpl" packagePath="br.ufc.mdcc.hpc.storm.binding.channel.impl">
    <baseType>
      <extensionType>
        <implements>true</implements>
      </extensionType>
      <component hash_component_UID="00240000048000009400000006020000002400005253413100040000110000005b27b7d5aeafa0c4504a854832157703202e4c9a35207e5b58958a6e88d34cb66c5fa403a5ab3bf94919420b99135247615e7473abbb6b3c1775e90661582bbc6de7e80dd11cb587417ad282070109720f3634da908310ad9a05a109b720186ac8ab9532a4c37f3e7837888e2beba7603bcaf55f32c66384c3e33d30df530eb3" localRef="base" location="br.ufc.mdcc.hpc.storm.binding.channel.Binding/Binding.hpe" name="Binding" package="br.ufc.mdcc.hpc.storm.binding.channel" version="1.0.0.0">
        <visualDescription h="60" w="173" x="226" y="237">
          <color b="255" g="255" r="255"/>
        </visualDescription>
        <unitBounds parallel="false" uRef="root">
          <visualDescription h="20" w="20" x="5" y="2"/>
        </unitBounds>
        <unitBounds parallel="true" uRef="peer">
          <visualDescription h="20" w="20" x="28" y="2"/>
        </unitBounds>
      </component>
    </baseType>
    <versions field1="1" field2="0" field3="0" field4="0"/>
    <visualAttributes>
      <color b="255" g="255" r="255"/>
    </visualAttributes>
  </header>
  <componentInfo>
    <interface iRef="IChannelRootImpl" nArgs="0">
      <sources sourceType="C# Language" versionId="1.0.0.0">
        <file contents="/* Automatically Generated Code */&#xA;&#xA;using System;&#xA;using br.ufc.pargo.hpe.backend.DGAC;&#xA;using br.ufc.pargo.hpe.basic;&#xA;using br.ufc.pargo.hpe.kinds;&#xA;using br.ufc.mdcc.hpc.storm.binding.channel.Binding;&#xA;&#xA;namespace br.ufc.mdcc.hpc.storm.binding.channel.impl.BindingImpl &#xA;{&#xA;&#x9;public abstract class BaseIChannelRootImpl: br.ufc.pargo.hpe.kinds.BindingRoot, BaseIChannelRoot&#xA;&#x9;{&#xA;&#x9;}&#xA;}" name="BaseIChannelRootImpl.cs" srcType="base" uri="br.ufc.mdcc.hpc.storm.binding.channel.impl.BindingImpl/bin/1.0.0.0/BaseIChannelRootImpl.dll" versionId="1.0.0.0">
          <dependency>br.ufc.mdcc.hpc.storm.binding.channel.Binding/bin/1.0.0.0/BaseIChannelRoot.dll</dependency>
          <externalDependency>MPI</externalDependency>
        </file>
        <file contents="using System;&#xA;using br.ufc.pargo.hpe.backend.DGAC;&#xA;using br.ufc.pargo.hpe.basic;&#xA;using br.ufc.pargo.hpe.kinds;&#xA;using br.ufc.mdcc.hpc.storm.binding.channel.Binding;&#xA;using MPI;&#xA;using System.Threading;&#xA;using System.Collections.Concurrent;&#xA;using System.Net;&#xA;using System.Net.Sockets;&#xA;using System.Collections.Generic;&#xA;using System.Runtime.Serialization.Formatters.Binary;&#xA;using System.IO;&#xA;&#xA;using EnvelopType = System.Tuple&lt;int,int,int,int,int,int>;&#xA;using System.Diagnostics;&#xA;&#xA;namespace br.ufc.mdcc.hpc.storm.binding.channel.impl.BindingImpl&#xA;{&#xA;&#x9;public class IChannelRootImpl : BaseIChannelRootImpl, IChannelRoot&#xA;&#x9;{&#xA;&#x9;&#x9;public const int TAG_SEND_OPERATION = 999;&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;private IDictionary&lt;int,Thread> thread_receive_requests = null;&#xA;&#xA;&#x9;&#x9;#region implemented abstract members of BindingRoot&#xA;&#x9;&#x9;public override void server ()&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;this.TraceFlag = true;&#xA;&#xA;&#x9;&#x9;&#x9;Trace.WriteLineIf(this.TraceFlag==true, this.GlobalRank + &quot;: BEFORE CREATE SOCKETS !!! &quot; + this.ThisFacet + &quot; / &quot; + this.ThisFacetInstance + &quot; : &quot; + this.CID.getInstanceName());&#xA;&#xA;&#x9;&#x9;&#x9;createSockets ();&#xA;&#xA;&#x9;&#x9;&#x9;Trace.WriteLineIf(this.TraceFlag==true, this.GlobalRank + &quot;: AFTER CREATED SOCKETS !!! &quot; + this.ThisFacet + &quot; / &quot; + this.ThisFacetInstance + &quot; : &quot; + this.CID.getInstanceName());&#xA;&#xA;&#x9;&#x9;&#x9;synchronizer_monitor = new SynchronizerMonitor (this, client_socket_facet, this.ThisFacetInstance, this.GlobalRank, this.CID.getInstanceName());&#xA;&#xA;&#x9;&#x9;&#x9;sockets_initialized_flag.Set ();&#xA;&#xA;&#x9;&#x9;&#x9;// Create the threads that will listen the sockets for each other facet.&#xA;&#x9;&#x9;&#x9;thread_receive_requests = new Dictionary&lt;int, Thread>();&#xA;&#xA;&#x9;&#x9;&#x9;foreach (int facet in this.Facet.Keys) &#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;if (facet != this.ThisFacetInstance)&#xA;&#x9;&#x9;&#x9;    {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Trace.WriteLineIf(this.TraceFlag==true, &quot;loop create thread_receive_requests: &quot; + facet + &quot; / &quot; + this.ThisFacetInstance);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Socket server_socket = server_socket_facet [facet];&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;thread_receive_requests[facet] = new Thread (new ThreadStart (() => synchronizer_monitor.serverReceiveRequests(facet, server_socket)));&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;thread_receive_requests[facet].Start ();&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;while (true) &#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;Thread.Sleep (100);&#xA;&#x9;&#x9;&#x9;&#x9;synchronizer_monitor.serverReadRequest ();&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;private AutoResetEvent sockets_initialized_flag = new AutoResetEvent(false);&#xA;&#xA;&#x9;&#x9;public override void client ()&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;this.TraceFlag = true;&#xA;&#xA;&#x9;&#x9;&#x9;//while (!sockets_initialized_flag)&#x9;Thread.Sleep (100);&#xA;&#x9;&#x9;&#x9;sockets_initialized_flag.WaitOne ();&#xA;&#xA;&#x9;&#x9;&#x9;Trace.WriteLineIf(this.TraceFlag==true, &quot;GO LISTEN WORKERS !!!&quot;);&#xA;&#x9;&#x9;&#x9;while (true) &#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;   listen_worker ();&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;#endregion&#xA;&#xA;&#x9;&#x9;private SynchronizerMonitor synchronizer_monitor;&#xA;&#xA;&#x9;&#x9;private IDictionary&lt;int, Socket> client_socket_facet = new Dictionary&lt;int, Socket>();&#xA;&#x9;&#x9;private IDictionary&lt;int, Socket> server_socket_facet = new Dictionary&lt;int, Socket>();&#xA;&#xA;&#x9;&#x9;private void connectSockets()&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;foreach (KeyValuePair&lt;int, FacetAccess> facet_access in this.Facet) &#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;int facet = facet_access.Key;&#xA;&#x9;&#x9;&#x9;&#x9;if (facet != this.ThisFacetInstance)&#xA;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Socket socket = client_socket_facet [facet];&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;IPEndPoint endPoint = end_point_client [facet];&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;bool isConnected = false;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;int tries = 0;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;while (!isConnected &amp;&amp; tries &lt;=30) &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;try {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;//Trace.WriteLineIf(this.TraceFlag==true, &quot;CONNECTING &quot; + &quot;facet=&quot; + facet + &quot; / &quot; + endPoint+ &quot; / &quot; + this.CID.getInstanceName());&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;socket.Connect (endPoint);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;isConnected = true;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;//Trace.WriteLineIf(this.TraceFlag==true, &quot;CONNECTED &quot; + &quot;facet=&quot; + facet + &quot; / &quot; + endPoint+ &quot; / &quot; + this.CID.getInstanceName());&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;catch (Exception e) &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;//tries ++;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;//isConnected = false;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;//Trace.WriteLineIf(this.TraceFlag==true, &quot;CONNECTION FAILED N --- ATTEMPT #&quot; + tries + &quot; *** &quot; + e.Message + &quot; --- &quot; + endPoint);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Thread.Sleep(1000);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (!isConnected) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Trace.WriteLineIf(this.TraceFlag==true, &quot;createSockets --- It was not possible to talk to the server&quot;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;throw new Exception (&quot;createSockets --- It was not possible to talk to the server&quot;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;private void acceptSockets ()&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;foreach (KeyValuePair&lt;int, FacetAccess> facet_access in this.Facet) &#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;int facet = facet_access.Key;&#xA;&#x9;&#x9;&#x9;&#x9;if (facet != this.ThisFacetInstance) &#xA;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Socket socket = server_socket_facet [facet];&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;IPEndPoint endPoint = end_point_server [facet];&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Trace.WriteLineIf(this.TraceFlag==true, &quot;BINDING &quot; + endPoint + &quot; -- &quot; + facet + &quot; / &quot; + this.CID.getInstanceName());&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;socket.Bind (endPoint) ;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;socket.Listen (10);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;server_socket_facet[facet] = socket.Accept ();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Trace.WriteLineIf(this.TraceFlag==true, &quot;BINDED &quot; + endPoint + &quot; -- &quot; + facet + &quot; / &quot; + this.CID.getInstanceName());&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;private IDictionary&lt;int,IPEndPoint> end_point_client = new Dictionary&lt;int,IPEndPoint>();&#xA;&#x9;&#x9;private IDictionary&lt;int,IPEndPoint> end_point_server = new Dictionary&lt;int,IPEndPoint>();&#xA;&#xA;&#xA;&#x9;&#x9;private void createSockets ()&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;FacetAccess facet_acess_server = this.Facet [ThisFacetInstance];&#xA;&#xA;&#x9;&#x9;&#x9;foreach (KeyValuePair&lt;int, FacetAccess> facet_access_client in this.Facet)&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;int facet_instance = facet_access_client.Key;&#xA;&#x9;&#x9;&#x9;&#x9;if (facet_instance != this.ThisFacetInstance) &#xA;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;string ip_address_client = facet_access_client.Value.ip_address;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;int port_client = facet_access_client.Value.port + this.ThisFacetInstance;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;IPHostEntry ipHostInfo_client = Dns.GetHostEntry (ip_address_client);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;IPAddress ipAddress_client = ipHostInfo_client.AddressList [0];&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;IPEndPoint endPoint_client = new IPEndPoint (ipAddress_client, port_client);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;end_point_client [facet_instance] = endPoint_client;&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Trace.WriteLineIf (this.TraceFlag == true, &quot;CREATE SOCKETS - end_point_client[&quot; + facet_instance + &quot;]=&quot; + endPoint_client);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;string ip_address_server = facet_acess_server.ip_address;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;int port_server = facet_acess_server.port + facet_instance;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;IPHostEntry ipHostInfo_server = Dns.GetHostEntry (ip_address_server);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;IPAddress ipAddress_server = ipHostInfo_server.AddressList [0];&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;IPEndPoint endPoint_server = new IPEndPoint (ipAddress_server, port_server);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;end_point_server [facet_instance] = endPoint_server;&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Trace.WriteLineIf (this.TraceFlag == true, &quot;CREATE SOCKETS - end_point_server[&quot; + facet_instance + &quot;]=&quot; + endPoint_server);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;// Create a TCP/IP client socket.&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Socket client_socket = new Socket (AddressFamily.InterNetwork, &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;                       SocketType.Stream, System.Net.Sockets.ProtocolType.Tcp);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;// Create a TCP/IP server socket.&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Socket server_socket = new Socket (AddressFamily.InterNetwork, &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;                       SocketType.Stream, System.Net.Sockets.ProtocolType.Tcp);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;server_socket.SendTimeout = server_socket.ReceiveTimeout = client_socket.SendTimeout = client_socket.ReceiveTimeout = -1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;client_socket_facet [facet_instance] = client_socket;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;server_socket_facet [facet_instance] = server_socket;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;Thread thread_connect_sockets = new Thread (new ThreadStart (connectSockets));&#xA;&#x9;&#x9;&#x9;Thread thread_accept_sockets = new Thread (new ThreadStart (acceptSockets));&#xA;&#xA;&#x9;&#x9;&#x9;thread_connect_sockets.Start();&#xA;&#x9;&#x9;&#x9;thread_accept_sockets.Start ();&#xA;&#xA;&#x9;&#x9;&#x9;Trace.WriteLineIf(this.TraceFlag==true, &quot;CREATE_SOCKETS - connectSockets and acceptSockets launched !!!&quot;);&#xA;&#xA;&#x9;&#x9;&#x9;thread_connect_sockets.Join ();&#xA;&#x9;&#x9;&#x9;thread_accept_sockets.Join ();&#xA;&#xA;&#x9;&#x9;&#x9;Trace.WriteLineIf(this.TraceFlag==true, &quot;CREATE_SOCKETS - connectSockets and acceptSockets finished !!!&quot;);&#xA;&#x9;&#x9;}&#x9;&#x9;&#x9;&#xA;&#xA;&#xA;&#xA;&#x9;&#x9;private void listen_worker ()&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;Tuple&lt;int,int> operation;&#xA;&#x9;&#x9;&#x9;MPI.CompletedStatus status = null;&#xA;&#xA;&#x9;&#x9;&#x9;Trace.WriteLineIf(this.TraceFlag==true, &quot;listen_workers - WAITING ... &quot; + MPI.Environment.Threading);&#xA;&#xA;&#x9;&#x9;&#x9;//lock (lock_recv)&#xA;&#x9;&#x9;&#x9;&#x9;RootCommunicator.Receive&lt;Tuple&lt;int,int>>&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;(MPI.Communicator.anySource, &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9; TAG_SEND_OPERATION,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9; out operation,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9; out status);&#xA;&#xA;&#x9;&#x9;&#x9;Trace.WriteLineIf(this.TraceFlag==true, &quot;listen_workers - RECEIVED FROM WORKER source=&quot; + status.Source + &quot;, tag=&quot; + status.Tag + &quot; / operation = &quot; + operation);&#xA;&#xA;&#x9;&#x9;&#x9;switch (operation.Item1) &#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;case AliencommunicatorOperation.SEND:&#xA;&#x9;&#x9;&#x9;&#x9;case AliencommunicatorOperation.SEND_ARRAY:&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;(new Thread(() => handle_SEND (operation, status))).Start();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;&#x9;case AliencommunicatorOperation.RECEIVE:&#xA;&#x9;&#x9;&#x9;&#x9;case AliencommunicatorOperation.RECEIVE_ARRAY:&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;(new Thread(() => handle_RECEIVE (operation, status))).Start();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;&#x9;case AliencommunicatorOperation.PROBE:&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;(new Thread(() => handle_PROBE(operation, status))).Start();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;&#x9;case AliencommunicatorOperation.ALL_GATHER:&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;(new Thread(() => handle_ALL_GATHER(operation, status))).Start();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;&#x9;case AliencommunicatorOperation.ALL_GATHER_FLATTENED:&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;(new Thread(() => handle_ALL_GATHER_FLATTENED(operation, status))).Start();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;&#x9;case AliencommunicatorOperation.ALL_REDUCE:&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;handle_ALL_REDUCE(operation, status);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;&#x9;case AliencommunicatorOperation.ALL_REDUCE_ARRAY:&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;(new Thread(() => handle_ALL_REDUCE(operation, status))).Start();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;&#x9;case AliencommunicatorOperation.ALL_TO_ALL:&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;(new Thread(() => handle_ALL_TO_ALL(operation, status))).Start();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;&#x9;case AliencommunicatorOperation.ALL_TO_ALL_FLATTENED:&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;(new Thread(() => handle_ALL_TO_ALL_FLATTENED(operation, status))).Start();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;&#x9;case AliencommunicatorOperation.REDUCE_SCATTER:&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;(new Thread(() => handle_REDUCE_SCATTER(operation, status))).Start();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;&#x9;case AliencommunicatorOperation.BROADCAST:&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;(new Thread(() => handle_BROADCAST(operation, status))).Start();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;&#x9;case AliencommunicatorOperation.BROADCAST_ARRAY:&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;(new Thread(() => handle_BROADCAST(operation, status))).Start();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;&#x9;case AliencommunicatorOperation.SCATTER:&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;handle_SCATTER(operation, status);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;&#x9;case AliencommunicatorOperation.SCATTER_FROM_FLATTENED:&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;(new Thread(() => &#x9;handle_SCATTER_FROM_FLATTENED(operation, status))).Start();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;&#x9;case AliencommunicatorOperation.GATHER:&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;(new Thread(() => handle_GATHER(operation, status))).Start();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;&#x9;case AliencommunicatorOperation.GATHER_FLATTENED:&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;(new Thread(() => handle_GATHER_FLATTENED(operation, status))).Start();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;&#x9;case AliencommunicatorOperation.REDUCE:&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;(new Thread(() => handle_REDUCE(operation, status))).Start();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;&#x9;case AliencommunicatorOperation.REDUCE_ARRAY:&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;(new Thread(() => handle_REDUCE(operation, status))).Start();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;&#x9;default:&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Trace.WriteLineIf(this.TraceFlag==true, &quot;UNRECOGNIZED OPERATION&quot;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;throw new ArgumentOutOfRangeException ();&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;void handle_SEND (Tuple&lt;int, int> operation, MPI.CompletedStatus status)&#xA;&#x9;&#x9;{&#xA;&#xA;&#x9;&#x9;&#x9;Trace.WriteLineIf(this.TraceFlag==true, status.Source + &quot;: handle_SEND 1 &quot; + operation);&#xA;&#xA;&#x9;&#x9;&#x9;Tuple&lt;int,int,int,byte[]> operation_info;&#xA;&#x9;&#x9;&#x9;int conversation_tag = operation.Item2;&#xA;&#x9;&#x9;&#x9;//lock (lock_recv) &#xA;&#x9;&#x9;&#x9;&#x9;this.RootCommunicator.Receive&lt;Tuple&lt;int,int,int,byte[]>> (status.Source, conversation_tag, out operation_info);&#xA;&#xA;&#x9;&#x9;&#x9;Trace.WriteLineIf(this.TraceFlag==true, status.Source + &quot;: handle_SEND 2 --- operation = &quot; + operation);&#xA;&#xA;&#x9;&#x9;&#x9;int operation_type = operation.Item1;&#xA;&#x9;&#x9;&#x9;int facet_src = this.ThisFacetInstance;&#xA;&#x9;&#x9;&#x9;int facet_dst = operation_info.Item1;&#xA;&#x9;&#x9;&#x9;int src = status.Source;&#xA;&#x9;&#x9;&#x9;int dst = operation_info.Item2;&#xA;&#x9;&#x9;&#x9;int tag = operation_info.Item3;&#xA;&#xA;&#x9;&#x9;&#x9;Trace.WriteLineIf(this.TraceFlag==true, status.Source + &quot;: handle_SEND 3 --- &quot; + facet_src + &quot;,&quot; + facet_dst + &quot;,&quot; + src + &quot;,&quot; + dst + &quot;,&quot; + tag + &quot;, operation = &quot; + operation);&#xA;&#xA;&#x9;&#x9;&#x9;EnvelopType envelop = new EnvelopType (operation_type, facet_src, facet_dst, src, dst, tag);&#xA;&#x9;&#x9;&#x9;byte[] message1 = operation_info.Item4;&#xA;&#x9;&#x9;&#x9;Trace.WriteLineIf(this.TraceFlag==true, status.Source + &quot;: handle_SEND 4 --- operation = &quot; + operation);&#xA;&#xA;&#x9;&#x9;&#x9;if (tag >=0 /* tag */)&#xA;&#x9;&#x9;&#x9;&#x9;synchronizer_monitor.clientSendRequest (envelop, message1);&#xA;&#x9;&#x9;&#x9;else&#xA;&#x9;&#x9;&#x9;&#x9;synchronizer_monitor.clientSendRequestAnyTag (envelop, message1, ref tag);&#xA;&#x9;&#x9;&#x9;Trace.WriteLineIf(this.TraceFlag==true, status.Source + &quot;: handle_SEND 5 --- operation = &quot; + operation);&#xA;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;//private object lock_recv = new object();&#xA;&#xA;&#x9;&#x9;void handle_RECEIVE (Tuple&lt;int, int> operation, MPI.CompletedStatus status)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;int conversation_tag = operation.Item2;&#xA;&#x9;&#x9;&#x9;Trace.WriteLineIf(this.TraceFlag==true, status.Source + &quot;: handle_RECEIVE 1 - source=&quot; + status.Source + &quot;, tag=&quot; + conversation_tag);&#xA;&#x9;&#x9;&#x9;Tuple&lt;int,int,int> operation_info;&#xA;&#xA;&#x9;&#x9;&#x9;//lock (lock_recv)&#xA;&#x9;&#x9;&#x9;&#x9;this.RootCommunicator.Receive&lt;Tuple&lt;int,int,int>> (status.Source, conversation_tag, out operation_info);&#xA;&#xA;&#x9;&#x9;&#x9;Trace.WriteLineIf(this.TraceFlag==true, status.Source + &quot;: handle_RECEIVE 2&quot;);&#xA;&#xA;&#x9;&#x9;&#x9;int operation_type = operation.Item1;&#xA;&#x9;&#x9;&#x9;int facet_src = this.ThisFacetInstance;&#xA;&#x9;&#x9;&#x9;int facet_dst = operation_info.Item1;&#xA;&#x9;&#x9;&#x9;int src = status.Source;&#xA;&#x9;&#x9;&#x9;int dst = operation_info.Item2;&#xA;&#x9;&#x9;&#x9;int tag = operation_info.Item3;&#xA;&#xA;&#x9;&#x9;&#x9;Trace.WriteLineIf(this.TraceFlag==true, status.Source + &quot;: handle_RECEIVE 3 --- &quot; + facet_src + &quot;,&quot; + facet_dst + &quot;,&quot; + src + &quot;,&quot; + dst + &quot;,&quot; + tag);&#xA;&#xA;&#x9;&#x9;&#x9;EnvelopType envelop = new EnvelopType (operation_type, facet_src, facet_dst, src, dst, tag);&#xA;&#x9;&#x9;&#x9;byte[] message2 = tag &lt; 0 ? synchronizer_monitor.clientSendRequestAnyTag (envelop, new byte[0], ref tag) : &#xA;&#x9;&#x9;&#x9;&#x9;                        synchronizer_monitor.clientSendRequest       (envelop, new byte[0]);&#xA;&#xA;&#x9;&#x9;&#x9;Trace.WriteLineIf(this.TraceFlag==true, status.Source + &quot;: handle_RECEIVE 4 &quot; + (message2 == null));&#xA;&#xA;&#x9;&#x9;&#x9;//lock (lock_recv)&#xA;&#x9;&#x9;&#x9;&#x9;this.RootCommunicator.Send&lt;byte[]>(message2, src, tag);&#xA;&#xA;&#x9;&#x9;&#x9;Trace.WriteLineIf(this.TraceFlag==true, status.Source + &quot;: handle_RECEIVE 5&quot;);&#xA;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;void handle_PROBE (Tuple&lt;int, int> operation, MPI.CompletedStatus status)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;throw new NotImplementedException ();&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;void handle_ALL_GATHER (Tuple&lt;int, int> operation, MPI.CompletedStatus status)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;throw new NotImplementedException ();&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;void handle_ALL_GATHER_FLATTENED (Tuple&lt;int, int> operation, MPI.CompletedStatus status)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;throw new NotImplementedException ();&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;void handle_ALL_REDUCE (Tuple&lt;int, int> operation, MPI.CompletedStatus status)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;throw new NotImplementedException ();&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;void handle_ALL_TO_ALL (Tuple&lt;int, int> operation, MPI.CompletedStatus status)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;throw new NotImplementedException ();&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;void handle_ALL_TO_ALL_FLATTENED (Tuple&lt;int, int> operation, MPI.CompletedStatus status)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;throw new NotImplementedException ();&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;void handle_REDUCE_SCATTER (Tuple&lt;int, int> operation, MPI.CompletedStatus status)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;throw new NotImplementedException ();&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;void handle_BROADCAST (Tuple&lt;int, int> operation, MPI.CompletedStatus status)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;throw new NotImplementedException ();&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;void handle_SCATTER (Tuple&lt;int, int> operation, MPI.CompletedStatus status)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;throw new NotImplementedException ();&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;void handle_SCATTER_FROM_FLATTENED (Tuple&lt;int, int> operation, MPI.CompletedStatus status)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;throw new NotImplementedException ();&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;void handle_GATHER (Tuple&lt;int, int> operation, MPI.CompletedStatus status)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;throw new NotImplementedException ();&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;void handle_GATHER_FLATTENED (Tuple&lt;int, int> operation, MPI.CompletedStatus status)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;throw new NotImplementedException ();&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;void handle_REDUCE (Tuple&lt;int, int> operation, MPI.CompletedStatus status)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;throw new NotImplementedException ();&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;#region IDisposable implementation&#xA;&#x9;&#x9;private bool disposed = false;&#xA;&#xA;&#x9;&#x9;protected override void Dispose(bool disposing)&#xA;&#x9;&#x9;{&#xA;&#xA;&#x9;&#x9;&#x9;if (!disposed)&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;if (disposing)&#xA;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Trace.WriteLineIf(this.TraceFlag==true, &quot;DISPOSING BINDING ROOT ...&quot;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;foreach (int i in thread_receive_requests.Keys)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;//for (int i=0; i&lt;thread_receive_requests.Count; i++)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (i != this.ThisFacetInstance)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;   thread_receive_requests[i].Abort ();&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;base.Dispose (disposing);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;//dispose unmanaged resources&#xA;&#x9;&#x9;&#x9;disposed = true;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;#endregion&#xA;&#xA;&#x9;}&#xA;&#xA;&#x9;class SynchronizerMonitor&#xA;&#x9;{&#xA;&#x9;&#x9;private int server_facet = default(int);&#xA;&#x9;&#x9;private int rank = default(int);&#xA;&#x9;&#x9;private string instance_name = null;&#xA;&#x9;&#x9;private IDictionary&lt;int,Socket> client_socket_facet = new Dictionary&lt;int,Socket>();&#xA;&#x9;&#x9;private IDictionary&lt;EnvelopKey, IDictionary&lt;int,Queue&lt;byte[]>>> reply_pending_list = new Dictionary&lt;EnvelopKey,IDictionary&lt;int,Queue&lt;byte[]>>>();&#xA;&#x9;&#x9;private IDictionary&lt;EnvelopKey, IDictionary&lt;int,Queue&lt;AutoResetEvent>>> request_pending_list = new Dictionary&lt;EnvelopKey,IDictionary&lt;int,Queue&lt;AutoResetEvent>>>();&#xA;&#x9;&#x9;private IChannelRootImpl unit;&#xA;&#xA;&#x9;&#x9;private object sync = new object();&#xA;&#xA;&#x9;&#x9;public SynchronizerMonitor (IChannelRootImpl unit, IDictionary&lt;int,Socket> client_socket_facet, int server_facet, int rank, string instance_name)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;this.unit = unit;&#xA;&#x9;&#x9;&#x9;this.client_socket_facet = client_socket_facet;&#xA;&#x9;&#x9;&#x9;this.server_facet = server_facet;&#xA;&#x9;&#x9;&#x9;this.rank = rank;&#xA;&#x9;&#x9;&#x9;this.instance_name = instance_name;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public byte[] clientSendRequest(EnvelopType envelop, byte[] messageSide1)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;EnvelopKey envelop_key = new EnvelopKey (envelop);&#xA;&#x9;&#x9;&#x9;int envelop_tag = envelop.Item6;&#xA;&#x9;&#x9;&#x9;Trace.WriteLineIf(unit.TraceFlag==true, server_facet + &quot;/&quot; + rank + &quot;: clientSendRequest 1&quot; + &quot; / &quot;  + envelop_key +&quot; -- &quot; + instance_name);&#xA;&#xA;&#x9;&#x9;&#x9;byte[] messageSide2 = null;&#xA;&#x9;&#x9;&#x9;Monitor.Enter (sync);&#xA;&#x9;&#x9;&#x9;try&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;// envia a requisi&#xe7;&#xe3;o para o root parceiro&#xA;&#x9;&#x9;&#x9;&#x9;int facet = envelop.Item3;&#xA;&#x9;&#x9;&#x9;&#x9;Trace.WriteLineIf(unit.TraceFlag==true, server_facet + &quot;/&quot; + rank + &quot;: clientSendRequest send to facet &quot; + facet + &quot; - nofsockets=&quot; + client_socket_facet.Count + &quot; / &quot;  + envelop_key+&quot; -- &quot; + instance_name);&#xA;&#x9;&#x9;&#x9;&#x9;foreach (int f in client_socket_facet.Keys)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Trace.WriteLineIf(unit.TraceFlag==true, server_facet + &quot;/&quot; + rank + &quot;: clientSendRequest --- FACET KEY=&quot; + f);&#xA;&#x9;&#x9;&#x9;&#x9;Socket socket = client_socket_facet [facet];&#xA;&#x9;&#x9;&#x9;&#x9;byte[] messageSide1_enveloped_raw = ObjectToByteArray (new Tuple&lt;EnvelopType,byte[]> (envelop, messageSide1));&#xA;&#x9;&#x9;&#x9;&#x9;Int32 length = messageSide1_enveloped_raw.Length;&#xA;&#x9;&#x9;&#x9;&#x9;byte[] messageSide1_enveloped_raw_ = new byte[4 + length];&#xA;&#x9;&#x9;&#x9;&#x9;BitConverter.GetBytes(length).CopyTo(messageSide1_enveloped_raw_,0);&#xA;&#x9;&#x9;&#x9;&#x9;Array.Copy(messageSide1_enveloped_raw, 0, messageSide1_enveloped_raw_, 4, length);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;socket.Send (messageSide1_enveloped_raw_);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;Trace.WriteLineIf(unit.TraceFlag==true, server_facet + &quot;/&quot; + rank + &quot;: clientSendRequest 2 nbytes=&quot; + messageSide1_enveloped_raw.Length + &quot; / &quot;  + envelop_key);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;// Verifica se j&#xe1; h&#xe1; resposta para a requisi&#xe7;&#xe3;o no &quot;conjunto de respostas pendentes de requisi&#xe7;&#xe3;o&quot;&#xA;&#x9;&#x9;&#x9;&#x9;if (!(reply_pending_list.ContainsKey (envelop_key) &amp;&amp; reply_pending_list [envelop_key].ContainsKey(envelop_tag)) || &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;(reply_pending_list.ContainsKey (envelop_key) &amp;&amp; reply_pending_list [envelop_key].ContainsKey(envelop_tag) &amp;&amp; reply_pending_list [envelop_key][envelop_tag].Count == 0)) &#xA;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Trace.WriteLineIf(unit.TraceFlag==true, server_facet + &quot;/&quot; + rank + &quot;: clientSendRequest 3 - BEFORE WAIT &quot; + envelop_key);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;// Se n&#xe3;o houver, coloca um item no &quot;conjunto de requisi&#xe7;&#xf5;es pendentes de resposta&quot; e espera.&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (!request_pending_list.ContainsKey(envelop_key))&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;request_pending_list [envelop_key] = new Dictionary&lt;int,Queue&lt;AutoResetEvent>>();&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (!request_pending_list [envelop_key].ContainsKey(envelop_tag))&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;request_pending_list [envelop_key][envelop_tag] = new Queue&lt;AutoResetEvent>();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;request_pending_list [envelop_key][envelop_tag].Enqueue(new AutoResetEvent(false));&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;AutoResetEvent sync_send = request_pending_list [envelop_key][envelop_tag].Peek();&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;//request_pending_list [envelop_key][envelop_tag] = sync_send;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Monitor.Exit(sync);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Console.WriteLine(&quot;clientSendRequest - WAIT / &quot; + unit.CID.getInstanceName() + &quot;/&quot; + sync_send.GetHashCode()  + &quot; BEFORE !!! &quot; );&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;sync_send.WaitOne();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Console.WriteLine(&quot;clientSendRequest - WAIT / &quot; + unit.CID.getInstanceName()  + &quot;/&quot; + sync_send.GetHashCode()  + &quot; AFTER !!! &quot; );&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Monitor.Enter(sync);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Trace.WriteLineIf(unit.TraceFlag==true, server_facet + &quot;/&quot; + rank + &quot;: clientSendRequest 3 - AFTER WAIT &quot; + envelop_key);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;Trace.WriteLineIf(unit.TraceFlag==true, server_facet + &quot;/&quot; + rank + &quot;: clientSendRequest 4&quot; + &quot; / &quot;  + envelop_key);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;Queue&lt;byte[]> pending_replies = reply_pending_list [envelop_key][envelop_tag];&#xA;&#x9;&#x9;&#x9;&#x9;Trace.WriteLineIf(unit.TraceFlag==true, server_facet + &quot;/&quot; + rank + &quot;: clientSendRequest 5 -- pending_replies.Count = &quot; + pending_replies.Count);&#xA;&#x9;&#x9;&#x9;&#x9;if (pending_replies.Count > 0)&#xA;&#x9;&#x9;&#x9;&#x9;   messageSide2 = reply_pending_list[envelop_key][envelop_tag].Dequeue();&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;if (pending_replies.Count == 0)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;reply_pending_list[envelop_key].Remove(envelop_tag);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;if (reply_pending_list[envelop_key].Count == 0)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;reply_pending_list.Remove(envelop_key);&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;//reply_pending_list.Remove(envelop_key);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;finally &#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;Monitor.Exit (sync);&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;Trace.WriteLineIf(unit.TraceFlag==true, server_facet + &quot;/&quot; + rank + &quot;: clientSendRequest 5&quot;);&#xA;&#x9;&#x9;&#x9;// retorna a menagem ...&#xA;&#x9;&#x9;&#x9;return messageSide2;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public byte[] clientSendRequestAnyTag(EnvelopType envelop, byte[] messageSide1, ref int envelop_tag)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;EnvelopKey envelop_key = new EnvelopKey (envelop);&#xA;&#x9;&#x9;&#x9;Trace.WriteLineIf(unit.TraceFlag==true, server_facet + &quot;/&quot; + rank + &quot;: clientSendRequestAnyTag 1&quot; + &quot; / &quot;  + envelop_key +&quot; -- &quot; + instance_name);&#xA;&#xA;&#x9;&#x9;&#x9;byte[] messageSide2 = null;&#xA;&#x9;&#x9;&#x9;Monitor.Enter (sync);&#xA;&#x9;&#x9;&#x9;try&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;// envia a requisi&#xe7;&#xe3;o para o root parceiro&#xA;&#x9;&#x9;&#x9;&#x9;int facet = envelop.Item3;&#xA;&#x9;&#x9;&#x9;&#x9;Trace.WriteLineIf(unit.TraceFlag==true, server_facet + &quot;/&quot; + rank + &quot;: clientSendRequestAnyTag send to facet &quot; + facet + &quot; - nofsockets=&quot; + client_socket_facet.Count + &quot; / &quot;  + envelop_key+&quot; -- &quot; + instance_name);&#xA;&#x9;&#x9;&#x9;&#x9;foreach (int f in client_socket_facet.Keys)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Trace.WriteLineIf(unit.TraceFlag==true, server_facet + &quot;/&quot; + rank + &quot;: clientSendRequestAnyTag --- FACET KEY=&quot; + f);&#xA;&#x9;&#x9;&#x9;&#x9;Socket socket = client_socket_facet [facet];&#xA;&#x9;&#x9;&#x9;&#x9;byte[] messageSide1_enveloped_raw = ObjectToByteArray (new Tuple&lt;EnvelopType,byte[]> (envelop, messageSide1));&#xA;&#x9;&#x9;&#x9;&#x9;Int32 length = messageSide1_enveloped_raw.Length;&#xA;&#x9;&#x9;&#x9;&#x9;byte[] messageSide1_enveloped_raw_ = new byte[4 + length];&#xA;&#x9;&#x9;&#x9;&#x9;BitConverter.GetBytes(length).CopyTo(messageSide1_enveloped_raw_,0);&#xA;&#x9;&#x9;&#x9;&#x9;Array.Copy(messageSide1_enveloped_raw, 0, messageSide1_enveloped_raw_, 4, length);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;socket.Send (messageSide1_enveloped_raw_);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;Trace.WriteLineIf(unit.TraceFlag==true, server_facet + &quot;/&quot; + rank + &quot;: clientSendRequestAnyTag 2 nbytes=&quot; + messageSide1_enveloped_raw.Length + &quot; / &quot;  + envelop_key);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;// Verifica se j&#xe1; h&#xe1; resposta para a requisi&#xe7;&#xe3;o no &quot;conjunto de respostas pendentes de requisi&#xe7;&#xe3;o&quot;&#xA;&#x9;&#x9;&#x9;&#x9;if (!reply_pending_list.ContainsKey (envelop_key))&#xA;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Trace.WriteLineIf(unit.TraceFlag==true, server_facet + &quot;/&quot; + rank + &quot;: clientSendRequestAnyTag 3 - BEFORE WAIT &quot; + envelop_key);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;// Se n&#xe3;o houver, coloca um item no &quot;conjunto de requisi&#xe7;&#xf5;es pendentes de resposta&quot; e espera.&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (!request_pending_list.ContainsKey(envelop_key))&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;request_pending_list [envelop_key] = new Dictionary&lt;int,Queue&lt;AutoResetEvent>>();&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (!request_pending_list [envelop_key].ContainsKey(-1))&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;request_pending_list [envelop_key][-1] = new Queue&lt;AutoResetEvent>();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;request_pending_list [envelop_key][-1].Enqueue(new AutoResetEvent(false));&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;AutoResetEvent sync_send = request_pending_list [envelop_key][-1].Peek();&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;//request_pending_list [envelop_key][envelop_tag] = sync_send;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Monitor.Exit(sync);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Console.WriteLine(&quot;clientSendRequestAny - WAIT / &quot; + unit.CID.getInstanceName() + &quot;/&quot; + sync_send.GetHashCode()  + &quot; BEFORE !!! &quot; );&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;sync_send.WaitOne()&#x9;;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Console.WriteLine(&quot;clientSendRequestAny - WAIT / &quot; + unit.CID.getInstanceName()  + &quot;/&quot; + sync_send.GetHashCode()  + &quot; AFTER !!! &quot; );&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Monitor.Enter(sync);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Trace.WriteLineIf(unit.TraceFlag==true, server_facet + &quot;/&quot; + rank + &quot;: clientSendRequestAnyTag 3 - AFTER WAIT &quot; + envelop_key);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;Trace.WriteLineIf(unit.TraceFlag==true, server_facet + &quot;/&quot; + rank + &quot;: clientSendRequestAnyTag 4&quot; + &quot; / &quot;  + envelop_key);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;int[] keys_vector = new int[reply_pending_list[envelop_key].Keys.Count];&#xA;&#x9;&#x9;&#x9;&#x9;reply_pending_list[envelop_key].Keys.CopyTo(keys_vector,0);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;envelop_tag = keys_vector[0];&#xA;&#x9;&#x9;&#x9;&#x9;Queue&lt;byte[]> pending_replies = reply_pending_list [envelop_key][envelop_tag];&#xA;&#x9;&#x9;&#x9;&#x9;Trace.WriteLineIf(unit.TraceFlag==true, server_facet + &quot;/&quot; + rank + &quot;: clientSendRequestAnyTag 5 -- pending_replies.Count = &quot; + pending_replies.Count);&#xA;&#x9;&#x9;&#x9;&#x9;if (pending_replies.Count > 0)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;messageSide2 = reply_pending_list[envelop_key][envelop_tag].Dequeue();&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;if (pending_replies.Count == 0)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;reply_pending_list[envelop_key].Remove(envelop_tag);&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;if (reply_pending_list[envelop_key].Count == 0)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;reply_pending_list.Remove(envelop_key);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;//reply_pending_list.Remove(envelop_key);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;finally &#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;Monitor.Exit (sync);&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;Trace.WriteLineIf(unit.TraceFlag==true, server_facet + &quot;/&quot; + rank + &quot;: clientSendRequest 5&quot;);&#xA;&#x9;&#x9;&#x9;// retorna a menagem ...&#xA;&#x9;&#x9;&#x9;return messageSide2;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;private static int BUFFER_SIZE = 1024*1024;&#xA;&#xA;&#x9;&#x9;public void serverReceiveRequests(int facet, Socket server_socket)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;byte[] buffer = new byte[BUFFER_SIZE];&#xA;&#x9;&#x9;&#x9;byte[] buffer2 = new byte[BUFFER_SIZE];&#xA;&#xA;&#x9;&#x9;&#x9;int nbytes = default(int);&#xA;&#xA;&#x9;&#x9;&#x9;Trace.WriteLineIf(unit.TraceFlag==true, &quot;serverReceiveRequest RECEIVE &quot; + unit.CID.getInstanceName() + &quot; / facet=&quot; + facet + &quot; BEFORE 1&quot;);&#xA;&#x9;&#x9;&#x9;nbytes = server_socket.Receive (buffer);&#x9;&#x9;    &#xA;&#x9;&#x9;&#x9;Trace.WriteLineIf(unit.TraceFlag==true, &quot;serverReceiveRequest RECEIVE &quot; + unit.CID.getInstanceName() + &quot; / facet=&quot; + facet + &quot; AFTER 1&quot;);&#xA;&#xA;&#x9;&#x9;&#x9;Trace.WriteLineIf(unit.TraceFlag==true, server_facet + &quot;/&quot; + rank + &quot;: serverReceiveRequests 1 - RECEIVED &quot; + nbytes + &quot; bytes -- &quot; + instance_name);&#xA;&#xA;&#x9;&#x9;&#x9;if (nbytes == 0) &#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;string error_message = server_facet + &quot;/&quot; + rank + &quot;: serverReceiveRequests  -- the partner &quot; + this.server_facet + &quot; is died &quot; + instance_name;&#xA;&#x9;&#x9;&#x9;&#x9;Trace.WriteLineIf(unit.TraceFlag==true, error_message);&#xA;&#x9;&#x9;&#x9;&#x9;throw new Exception(error_message);&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;while (true)&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;int length = BitConverter.ToInt32(buffer,0);&#xA;&#x9;&#x9;&#x9;&#x9;nbytes = nbytes - 4;&#xA;&#x9;&#x9;&#x9;&#x9;byte[] message = new byte[length];&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;Trace.WriteLineIf(unit.TraceFlag==true, server_facet + &quot;/&quot; + rank + &quot;: serverReceiveRequests 2 - length is &quot; + length + &quot; bytes&quot; + &quot; / nbytes = &quot; + nbytes);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;Array.Copy(buffer, 4, message, 0, length);&#xA;&#x9;&#x9;&#x9;&#x9;requestQueue.Add (message);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;if (nbytes == length) &#xA;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Trace.WriteLineIf(unit.TraceFlag==true,&quot;serverReceiveRequest RECEIVE &quot; + unit.CID.getInstanceName() + &quot; / facet=&quot; + facet + &quot; BEFORE 2&quot;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;nbytes = server_socket.Receive (buffer);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Trace.WriteLineIf(unit.TraceFlag==true,&quot;serverReceiveRequest RECEIVE &quot; + unit.CID.getInstanceName() + &quot; / facet=&quot; + facet + &quot; AFTER 2&quot;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Trace.WriteLineIf(unit.TraceFlag==true, server_facet + &quot;/&quot; + rank + &quot;: serverReceiveRequests 3 - RECEIVED &quot; + nbytes + &quot; bytes --- &quot; + instance_name);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (nbytes == 0) &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;string error_message = server_facet + &quot;/&quot; + rank + &quot;: serverReceiveRequests  -- the partner &quot; + this.server_facet + &quot; is died &quot; + instance_name;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Trace.WriteLineIf(unit.TraceFlag==true, error_message);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;throw new Exception(error_message);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;} &#xA;&#x9;&#x9;&#x9;&#x9;else if (nbytes > length) &#xA;&#x9;&#x9;&#x9;&#x9;{ &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;// assume that nbytes - length > 4&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;byte[] aux = buffer;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;nbytes = nbytes - length;&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Array.Copy(buffer, length + 4, buffer2, 0, nbytes);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;buffer = buffer2;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;buffer2 = aux;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Trace.WriteLineIf(unit.TraceFlag==true, server_facet + &quot;/&quot; + rank + &quot;: serverReceiveRequests 4 - nbytes=&quot; + nbytes);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;else&#xA;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;string error_message = server_facet + &quot;/&quot; + rank + &quot;: UNEXPECTED CONDITION nbytes=&quot; + nbytes + &quot; &lt; length=&quot; + length;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Trace.WriteLineIf(unit.TraceFlag==true, error_message);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;throw new Exception(error_message);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;private ProducerConsumerQueue&lt;byte[]> requestQueue = new ProducerConsumerQueue&lt;byte[]>();&#xA;&#xA;&#x9;&#x9;public void serverReadRequest() &#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;Trace.WriteLineIf(unit.TraceFlag==true, server_facet + &quot;/&quot; + rank + &quot;: serverReadRequest 1 &quot;);&#xA;&#xA;&#x9;&#x9;&#x9;byte[] buffer =&#x9;requestQueue.Take ();&#xA;&#x9;&#x9;&#x9;int nbytes =  buffer.Length;&#xA;&#xA;&#x9;&#x9;&#x9;Trace.WriteLineIf(unit.TraceFlag==true, server_facet + &quot;/&quot; + rank + &quot;: serverReadRequest 2 &quot; + nbytes + &quot; bytes received.&quot;);&#xA;&#xA;&#x9;&#x9;&#x9;Monitor.Enter (sync);&#xA;&#x9;&#x9;&#x9;try&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;// Aguarda uma resposta proveniente do outro root parceiro.&#xA;&#x9;&#x9;&#x9;&#x9;byte[] messageSide1_enveloped_raw = new byte[nbytes];&#xA;&#x9;&#x9;&#x9;&#x9;Trace.WriteLineIf(unit.TraceFlag==true, server_facet + &quot;/&quot; + rank + &quot;: serverReadRequest 2-1 nbytes=&quot; + nbytes);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;// TODO: otimizar isso ...&#xA;&#x9;&#x9;&#x9;&#x9;for (int i=0; i&lt;nbytes; i++)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;messageSide1_enveloped_raw[i] = buffer[i];&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;Tuple&lt;EnvelopType,byte[]> messageSide1_enveloped = (Tuple&lt;EnvelopType,byte[]>) ByteArrayToObject (messageSide1_enveloped_raw);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;EnvelopType envelop = messageSide1_enveloped.Item1;&#xA;&#x9;&#x9;&#x9;&#x9;EnvelopKey envelop_key = new EnvelopKey (envelop);&#xA;&#x9;&#x9;&#x9;&#x9;int envelop_tag = envelop.Item6;&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;// Coloca a resposta no &quot;conjunto de respostas pendentes de requisi&#xe7;&#xe3;o&quot;&#xA;&#x9;&#x9;&#x9;&#x9;if (!reply_pending_list.ContainsKey(envelop_key))&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;reply_pending_list [envelop_key] = new Dictionary&lt;int,Queue&lt;byte[]>>();&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;if (!reply_pending_list [envelop_key].ContainsKey(envelop_tag))&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;reply_pending_list [envelop_key][envelop_tag] = new Queue&lt;byte[]>();&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;reply_pending_list [envelop_key][envelop_tag].Enqueue(messageSide1_enveloped.Item2);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;Trace.WriteLineIf(unit.TraceFlag==true, server_facet + &quot;/&quot; + rank + &quot;: serverReadRequest 3 &quot; + envelop.Item1 + &quot;,&quot; +  envelop_key);&#xA;&#x9;&#x9;&#x9;&#x9;foreach (EnvelopKey ek in request_pending_list.Keys) &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Trace.WriteLineIf(unit.TraceFlag==true, server_facet + &quot;: key: &quot; + ek);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;// Busca, no &quot;conjunto de requisi&#xe7;&#xf5;es pendentes de resposta&quot;, a requisi&#xe7;&#xe3;o correspondente a resposta.&#xA;&#x9;&#x9;&#x9;&#x9;if (request_pending_list.ContainsKey (envelop_key) &amp;&amp; request_pending_list[envelop_key].ContainsKey(envelop_tag)) &#xA;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Trace.WriteLineIf(unit.TraceFlag==true, server_facet + &quot;/&quot; + rank + &quot;: serverReadRequest 3-1&quot; + &quot; / &quot;  + envelop_key);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;AutoResetEvent sync_send = request_pending_list[envelop_key][envelop_tag].Dequeue();&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;sync_send.Set();&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (request_pending_list[envelop_key][envelop_tag].Count == 0)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;request_pending_list[envelop_key].Remove(envelop_tag);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (request_pending_list[envelop_key].Count==0)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;request_pending_list.Remove(envelop_key);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Trace.WriteLineIf(unit.TraceFlag==true, server_facet + &quot;/&quot; + rank + &quot;: serverReadRequest 3-2&quot;+ &quot; / &quot;  + envelop_key) ;&#xA;&#x9;&#x9;&#x9;&#x9;} &#xA;&#x9;&#x9;&#x9;&#x9;else if (request_pending_list.ContainsKey (envelop_key) &amp;&amp; request_pending_list[envelop_key].ContainsKey(-1)) &#xA;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Trace.WriteLineIf(unit.TraceFlag==true, server_facet + &quot;/&quot; + rank + &quot;: serverReadRequest 3-1&quot; + &quot; / &quot;  + envelop_key);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;AutoResetEvent sync_send = request_pending_list[envelop_key][-1].Dequeue();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;//Monitor.Pulse (sync_send);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;sync_send.Set();&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (request_pending_list[envelop_key][-1].Count == 0)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;request_pending_list[envelop_key].Remove(-1);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (request_pending_list[envelop_key].Count==0)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;request_pending_list.Remove(envelop_key);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Trace.WriteLineIf(unit.TraceFlag==true, server_facet + &quot;/&quot; + rank + &quot;: serverReadRequest 3-2&quot;+ &quot; / &quot;  + envelop_key) ;&#xA;&#x9;&#x9;&#x9;&#x9;}  &#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;finally &#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;Monitor.Exit (sync);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;Trace.WriteLineIf(unit.TraceFlag==true, server_facet + &quot;/&quot; + rank + &quot;: serverReadRequest 4&quot;);&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;// Convert an object to a byte array&#xA;&#x9;&#x9;private static byte[] ObjectToByteArray(Object obj)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;if(obj == null)&#xA;&#x9;&#x9;&#x9;&#x9;return null;&#xA;&#x9;&#x9;&#x9;BinaryFormatter bf = new BinaryFormatter();&#xA;&#x9;&#x9;&#x9;MemoryStream ms = new MemoryStream();&#xA;&#x9;&#x9;&#x9;bf.Serialize(ms, obj);&#xA;&#x9;&#x9;&#x9;return ms.ToArray();&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;// Convert a byte array to an Object&#xA;&#x9;&#x9;private static Object ByteArrayToObject(byte[] arrBytes)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;MemoryStream memStream = new MemoryStream();&#xA;&#x9;&#x9;&#x9;BinaryFormatter binForm = new BinaryFormatter();&#xA;&#x9;&#x9;&#x9;memStream.Write(arrBytes, 0, arrBytes.Length);&#xA;&#x9;&#x9;&#x9;memStream.Seek(0, SeekOrigin.Begin);&#xA;&#x9;&#x9;&#x9;Object obj = (Object) binForm.Deserialize(memStream);&#xA;&#x9;&#x9;&#x9;return obj;&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;class EnvelopKey&#xA;&#x9;{&#xA;&#x9;&#x9;private EnvelopType envelop = null;&#xA;&#x9;&#x9;public EnvelopKey(EnvelopType envelop)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;this.envelop = envelop;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public override string ToString ()&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;string key=base.ToString();&#xA;&#x9;&#x9;&#x9;switch (envelop.Item1) {&#xA;&#x9;&#x9;&#x9;case AliencommunicatorOperation.SEND:&#xA;&#x9;&#x9;&#x9;case AliencommunicatorOperation.SEND_ARRAY:&#xA;//&#x9;&#x9;&#x9;&#x9;key = string.Format (&quot;SR-{0}-{1}-{2}-{3}-{4}&quot;,envelop.Item2, envelop.Item3, envelop.Item4, envelop.Item5, envelop.Item6);&#xA;&#x9;&#x9;&#x9;&#x9;key = string.Format (&quot;SR-{0}-{1}-{2}-{3}&quot;,envelop.Item2, envelop.Item3, envelop.Item4, envelop.Item5);&#xA;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;case AliencommunicatorOperation.RECEIVE:&#xA;&#x9;&#x9;&#x9;case AliencommunicatorOperation.RECEIVE_ARRAY:&#xA;//&#x9;&#x9;&#x9;&#x9;key = string.Format (&quot;SR-{1}-{0}-{3}-{2}-{4}&quot;,envelop.Item2, envelop.Item3, envelop.Item4, envelop.Item5, envelop.Item6);&#xA;&#x9;&#x9;&#x9;&#x9;key = string.Format (&quot;SR-{1}-{0}-{3}-{2}&quot;,envelop.Item2, envelop.Item3, envelop.Item4, envelop.Item5);&#xA;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;case AliencommunicatorOperation.PROBE:&#xA;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;case AliencommunicatorOperation.ALL_GATHER:&#xA;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;case AliencommunicatorOperation.ALL_GATHER_FLATTENED:&#xA;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;case AliencommunicatorOperation.ALL_REDUCE:&#xA;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;case AliencommunicatorOperation.ALL_REDUCE_ARRAY:&#xA;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;case AliencommunicatorOperation.ALL_TO_ALL:&#xA;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;case AliencommunicatorOperation.ALL_TO_ALL_FLATTENED:&#xA;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;case AliencommunicatorOperation.REDUCE_SCATTER:&#xA;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;case AliencommunicatorOperation.BROADCAST:&#xA;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;case AliencommunicatorOperation.BROADCAST_ARRAY:&#xA;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;case AliencommunicatorOperation.SCATTER:&#xA;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;case AliencommunicatorOperation.SCATTER_FROM_FLATTENED:&#xA;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;case AliencommunicatorOperation.GATHER:&#xA;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;case AliencommunicatorOperation.GATHER_FLATTENED:&#xA;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;case AliencommunicatorOperation.REDUCE:&#xA;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;case AliencommunicatorOperation.REDUCE_ARRAY:&#xA;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;default:&#xA;&#x9;&#x9;&#x9;&#x9;throw new ArgumentOutOfRangeException ();&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;return key;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public override bool Equals(object obj)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;EnvelopKey fooItem = obj as EnvelopKey;&#xA;&#xA;&#x9;&#x9;&#x9;return fooItem.ToString().Equals(this.ToString());&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public override int GetHashCode ()&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;return this.ToString().GetHashCode();&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;}&#xA;&#xA;&#x9;public class ProducerConsumerQueue&lt;T> : BlockingCollection&lt;T>&#xA;&#x9;{&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// Initializes a new instance of the ProducerConsumerQueue, Use Add and TryAdd for Enqueue and TryEnqueue and Take and TryTake for Dequeue and TryDequeue functionality&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;public ProducerConsumerQueue()  &#xA;&#x9;&#x9;&#x9;: base(new ConcurrentQueue&lt;T>())&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// Initializes a new instance of the ProducerConsumerQueue, Use Add and TryAdd for Enqueue and TryEnqueue and Take and TryTake for Dequeue and TryDequeue functionality&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;/// &lt;param name=&quot;maxSize&quot;>&lt;/param>&#xA;&#x9;&#x9;public ProducerConsumerQueue(int maxSize)&#xA;&#x9;&#x9;&#x9;: base(new ConcurrentQueue&lt;T>(), maxSize)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;}&#xA;&#xA;&#xA;&#xA;&#x9;}&#xA;&#xA;}&#xA;" name="IChannelRootImpl.cs" srcType="user" uri="br.ufc.mdcc.hpc.storm.binding.channel.impl.BindingImpl/bin/1.0.0.0/IChannelRootImpl.dll" versionId="1.0.0.0">
          <dependency>%WORKSPACE/br.ufc.mdcc.hpc.storm.binding.channel.impl.BindingImpl/bin/1.0.0.0/BaseIChannelRootImpl.dll</dependency>
          <dependency>br.ufc.mdcc.hpc.storm.binding.channel.Binding/bin/1.0.0.0/IChannelRoot.dll</dependency>
          <externalDependency>MPI</externalDependency>
        </file>
      </sources>
      <visualDescription h="40" w="172" x="197" y="47">
        <color b="0" g="165" r="255"/>
      </visualDescription>
      <externalReferences>MPI</externalReferences>
    </interface>
    <interface iRef="IChannelImpl" nArgs="0">
      <sources sourceType="C# Language" versionId="1.0.0.0">
        <file contents="/* Automatically Generated Code */&#xA;&#xA;using System;&#xA;using br.ufc.pargo.hpe.backend.DGAC;&#xA;using br.ufc.pargo.hpe.basic;&#xA;using br.ufc.pargo.hpe.kinds;&#xA;using br.ufc.mdcc.hpc.storm.binding.channel.Binding;&#xA;&#xA;namespace br.ufc.mdcc.hpc.storm.binding.channel.impl.BindingImpl &#xA;{&#xA;&#x9;public abstract class BaseIChannelImpl: br.ufc.pargo.hpe.kinds.Binding, BaseIChannel&#xA;&#x9;{&#xA;&#xA;&#x9;}&#xA;}" name="BaseIChannelImpl.cs" srcType="base" uri="br.ufc.mdcc.hpc.storm.binding.channel.impl.BindingImpl/bin/1.0.0.0/BaseIChannelImpl.dll" versionId="1.0.0.0">
          <dependency>br.ufc.mdcc.hpc.storm.binding.channel.Binding/bin/1.0.0.0/BaseIChannel.dll</dependency>
          <externalDependency>MPI</externalDependency>
        </file>
        <file contents="using System;&#xA;using br.ufc.pargo.hpe.backend.DGAC;&#xA;using br.ufc.pargo.hpe.basic;&#xA;using br.ufc.pargo.hpe.kinds;&#xA;using br.ufc.mdcc.hpc.storm.binding.channel.Binding;&#xA;using MPI;&#xA;using System.Runtime.Serialization.Formatters.Binary;&#xA;using System.IO;&#xA;using System.Diagnostics;&#xA;&#xA;namespace br.ufc.mdcc.hpc.storm.binding.channel.impl.BindingImpl&#xA;{&#xA;&#x9;public class IChannelImpl : BaseIChannelImpl, IChannel&#xA;&#x9;{&#xA;&#x9;&#x9;public const int TAG_SEND_OPERATION = 999;&#xA;&#xA;&#x9;&#x9;private int conversation_tag = 100;&#xA;&#xA;&#x9;&#x9;object sync = new object();&#xA;&#xA;&#x9;&#x9;private int takeNextConversationTag()&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;lock (sync) &#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;conversation_tag ++;&#xA;&#x9;&#x9;&#x9;&#x9;switch (conversation_tag) {&#xA;&#x9;&#x9;&#x9;&#x9;case TAG_SEND_OPERATION:&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;conversation_tag ++;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;&#x9;case int.MaxValue:&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;conversation_tag = 10;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;return /*100*this.PeerRank +*/ conversation_tag;&#xA;&#x9;&#x9;}&#xA;&#xA;&#xA;&#x9;&#x9;// AlienCommunicator&#xA;&#xA;&#x9;&#x9;public const int Root = default(int);&#xA;&#x9;&#x9;public const int Null = default(int);&#xA;&#xA;&#x9;&#x9;public int RemoteSize&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;get&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;throw new NotImplementedException ();&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;#region Point-to-Point implementation&#xA;&#xA;&#x9;&#x9;// Send&#xA;&#xA;&#x9;&#x9;public void Send&lt;T> (T value, Tuple&lt;int,int> dest, int tag)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;//int conversation_tag = takeNextConversationTag();&#xA;&#x9;&#x9;&#x9;Trace.WriteLineIf(this.TraceFlag==true, &quot;CHECKING &quot; + this.RootCommunicator.Rank + &quot;,&quot; + dest.Item2 + &quot;, tag=&quot; + tag);&#xA;&#xA;&#x9;&#x9;&#x9;Trace.WriteLineIf(this.TraceFlag==true, this.PeerRank + &quot;: 1 - BEGIN SEND TO &lt;&quot; + dest.Item1 + &quot;,&quot; + dest.Item2 +  &quot;> : &quot; + TAG_SEND_OPERATION);&#xA;&#x9;&#x9;&#x9;/* lock (lock_mpi) */ this.RootCommunicator.Send&lt;Tuple&lt;int, int>>(new Tuple&lt;int, int>(AliencommunicatorOperation.SEND, tag), 0, TAG_SEND_OPERATION);&#xA;&#x9;&#x9;&#x9;Trace.WriteLineIf(this.TraceFlag==true, this.PeerRank + &quot;: 2 - BEGIN SEND TO &lt;&quot; + dest.Item1 + &quot;,&quot; + dest.Item2 +  &quot;> : &quot; + tag);&#xA;&#xA;&#x9;&#x9;&#x9;byte[] value_packet = ObjectToByteArray (value);&#xA;&#xA;&#x9;&#x9;&#x9;/* lock (lock_mpi) */ this.RootCommunicator.Send&lt;Tuple&lt;int,int,int,byte[]>> (new Tuple&lt;int,int,int,byte[]>(dest.Item1, dest.Item2, tag, value_packet), 0, tag);&#xA;&#x9;&#x9;&#x9;Trace.WriteLineIf(this.TraceFlag==true, this.PeerRank + &quot;: 3 - END SEND TO &lt;&quot; + dest.Item1 + &quot;,&quot; + dest.Item2+  &quot;>&quot;);&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public br.ufc.mdcc.hpc.storm.binding.channel.Binding.Request ImmediateSend&lt;T> (T value, Tuple&lt;int,int> dest, int tag)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;//int conversation_tag = takeNextConversationTag();&#xA;&#x9;&#x9;&#x9;Trace.WriteLineIf(this.TraceFlag==true, this.PeerRank + &quot;: CHECKING &quot; + this.RootCommunicator.Rank + &quot;,&quot; + dest.Item2 + &quot;, tag=&quot; + tag);&#xA;&#x9;&#x9;&#x9;Trace.WriteLineIf(this.TraceFlag==true, this.PeerRank + &quot;: 1 - BEGIN SEND TO &lt;&quot; + dest.Item1 + &quot;,&quot; + dest.Item2 +  &quot;> : &quot; + TAG_SEND_OPERATION);&#xA;&#x9;&#x9;&#x9;/* lock (lock_mpi) */ this.RootCommunicator.Send&lt;Tuple&lt;int, int>>(new Tuple&lt;int, int>(AliencommunicatorOperation.SEND, tag), 0, TAG_SEND_OPERATION);&#xA;&#x9;&#x9;&#x9;Trace.WriteLineIf(this.TraceFlag==true, this.PeerRank + &quot;: 2 - BEGIN SEND TO &lt;&quot; + dest.Item1 + &quot;,&quot; + dest.Item2 +  &quot;> : &quot; + tag);&#xA;&#x9;&#x9;&#x9;byte[] value_packet = ObjectToByteArray (value);&#xA;&#x9;&#x9;&#x9;MPI.Request root_request = this.RootCommunicator.ImmediateSend&lt;Tuple&lt;int,int,int,byte[]>> (new Tuple&lt;int,int,int,byte[]>(dest.Item1, dest.Item2, tag, value_packet), 0, tag);&#xA;&#x9;&#x9;&#x9;Trace.WriteLineIf(this.TraceFlag==true, this.PeerRank + &quot;: 3 - END SEND TO &lt;&quot; + dest.Item1 + &quot;,&quot; + dest.Item2 );&#xA;&#x9;&#x9;&#x9;return br.ufc.mdcc.hpc.storm.binding.channel.Binding.Request.createRequest (root_request, dest);&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;// Send Array&#xA;&#xA;&#x9;&#x9;public void Send&lt;T> (T[] values, Tuple&lt;int,int> dest, int tag)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;//int conversation_tag = takeNextConversationTag();&#xA;&#x9;&#x9;&#x9;/* lock (lock_mpi) */ this.RootCommunicator.Send&lt;Tuple&lt;int, int>>(new Tuple&lt;int, int>(AliencommunicatorOperation.SEND_ARRAY, tag), 0, TAG_SEND_OPERATION);&#xA;&#x9;&#x9;&#x9;byte[] value_packet = ObjectToByteArray (values);&#xA;&#x9;&#x9;&#x9;/* lock (lock_mpi) */ this.RootCommunicator.Send&lt;Tuple&lt;int,int,int,byte[]>> (new Tuple&lt;int,int,int,byte[]>(dest.Item1, dest.Item2, tag, value_packet), 0, tag);&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public br.ufc.mdcc.hpc.storm.binding.channel.Binding.Request ImmediateSend&lt;T> (T[] values, Tuple&lt;int,int> dest, int tag)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;//int conversation_tag = takeNextConversationTag();&#x9;&#xA;&#x9;&#x9;&#x9;Trace.WriteLineIf(this.TraceFlag==true, this.PeerRank + &quot;: CHECKING &quot; + this.RootCommunicator.Rank + &quot;,&quot; + dest.Item2);&#xA;&#x9;&#x9;&#x9;Trace.WriteLineIf(this.TraceFlag==true, this.PeerRank + &quot;: 1 - BEGIN SEND TO &lt;&quot; + dest.Item1 + &quot;,&quot; + dest.Item2 + &quot;> : &quot; + TAG_SEND_OPERATION);&#xA;&#x9;&#x9;&#x9;/* lock (lock_mpi) */ this.RootCommunicator.Send&lt;Tuple&lt;int, int>>(new Tuple&lt;int, int>(AliencommunicatorOperation.SEND_ARRAY, tag), 0, TAG_SEND_OPERATION);&#xA;&#x9;&#x9;&#x9;Trace.WriteLineIf(this.TraceFlag==true, this.PeerRank + &quot;: 2 - BEGIN SEND TO &lt;&quot; + dest.Item1 + &quot;,&quot; + dest.Item2 + &quot;> : &quot; + tag);&#xA;&#x9;&#x9;&#x9;byte[] value_packet = ObjectToByteArray (values);&#xA;&#x9;&#x9;&#x9;MPI.Request root_request = this.RootCommunicator.ImmediateSend&lt;Tuple&lt;int,int,int,byte[]>> (new Tuple&lt;int,int,int,byte[]>(dest.Item1, dest.Item2, tag, value_packet), 0, tag);&#xA;&#x9;&#x9;&#x9;Trace.WriteLineIf(this.TraceFlag==true, this.PeerRank + &quot;: 3 - END SEND TO &lt;&quot; + dest.Item1 + &quot;,&quot; + dest.Item2 + &quot;>&quot;);&#xA;&#x9;&#x9;&#x9;return br.ufc.mdcc.hpc.storm.binding.channel.Binding.Request.createRequest (root_request, dest);&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;// Receive&#xA;&#xA;&#x9;&#x9;public T Receive&lt;T> (Tuple&lt;int,int> source, int tag)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;T result;&#xA;&#x9;&#x9;&#x9;Receive(source, tag, out result);&#xA;&#x9;&#x9;&#x9;return result;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public void Receive&lt;T> (Tuple&lt;int,int> source, int tag, out T value)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;br.ufc.mdcc.hpc.storm.binding.channel.Binding.CompletedStatus status;&#xA;&#x9;&#x9;&#x9;Receive(source, tag, out value, out status);&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;//private object lock_mpi = new object();&#xA;&#xA;&#x9;&#x9;public void Receive&lt;T> (Tuple&lt;int,int> source, int tag, out T value, out br.ufc.mdcc.hpc.storm.binding.channel.Binding.CompletedStatus status)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;int conversation_tag = takeNextConversationTag();&#xA;&#x9;&#x9;&#x9;Trace.WriteLineIf(this.TraceFlag==true, this.PeerRank + &quot;: 1 - BEGIN RECV FROM &lt;&quot; + source.Item1 + &quot;,&quot; + source.Item2 + &quot;> : &quot; + TAG_SEND_OPERATION);&#xA;&#x9;&#x9;&#x9;/* lock (lock_mpi) */ this.RootCommunicator.Send&lt;Tuple&lt;int, int>>(new Tuple&lt;int, int>(AliencommunicatorOperation.RECEIVE, conversation_tag), 0, TAG_SEND_OPERATION);&#xA;&#x9;&#x9;&#x9;Trace.WriteLineIf(this.TraceFlag==true, this.PeerRank + &quot;: 2 - BEGIN RECV FROM &lt;&quot; + source.Item1 + &quot;,&quot; + source.Item2 + &quot;> : &quot; + conversation_tag);&#xA;&#x9;&#x9;&#x9;/* lock (lock_mpi) */ this.RootCommunicator.Send&lt;Tuple&lt;int,int,int>> (new Tuple&lt;int,int,int>(source.Item1, source.Item2, tag), 0, conversation_tag);&#xA;&#x9;&#x9;&#x9;Trace.WriteLineIf(this.TraceFlag==true, this.PeerRank + &quot;: 3 - BEGIN RECV FROM &lt;&quot; + source.Item1 + &quot;,&quot; + source.Item2 + &quot;> : &quot; + tag);&#xA;&#x9;&#x9;&#x9;MPI.CompletedStatus status_root;&#xA;&#x9;&#x9;&#x9;byte[] v;&#xA;&#x9;&#x9;&#x9;/* lock (lock_mpi) */ this.RootCommunicator.Receive&lt;byte[]> (0, tag, out v, out status_root);&#xA;&#x9;&#x9;&#x9;value = (T) ByteArrayToObject(v);&#xA;&#x9;&#x9;&#x9;Trace.WriteLineIf(this.TraceFlag==true, this.PeerRank + &quot;: 4 - END RECV FROM &lt;&quot; + source.Item1 + &quot;,&quot; + source.Item2 + &quot;>&quot;);&#xA;&#xA;&#x9;&#x9;&#x9;status = br.ufc.mdcc.hpc.storm.binding.channel.Binding.CompletedStatus.createStatus(status_root, source);&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public br.ufc.mdcc.hpc.storm.binding.channel.Binding.ReceiveRequest ImmediateReceive&lt;T> (Tuple&lt;int,int> source, int tag)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;int conversation_tag = takeNextConversationTag();&#xA;&#x9;&#x9;&#x9;Trace.WriteLineIf(this.TraceFlag==true, this.PeerRank + &quot;: 1 - BEGIN RECV FROM &lt;&quot; + source.Item1 + &quot;,&quot; + source.Item2 + &quot;> : &quot; + TAG_SEND_OPERATION);&#xA;&#x9;&#x9;&#x9;/* lock (lock_mpi) */ this.RootCommunicator.Send&lt;Tuple&lt;int, int>>(new Tuple&lt;int, int>(AliencommunicatorOperation.RECEIVE, conversation_tag), 0, TAG_SEND_OPERATION);&#xA;&#x9;&#x9;&#x9;Trace.WriteLineIf(this.TraceFlag==true, this.PeerRank + &quot;: 2 - BEGIN RECV FROM &lt;&quot; + source.Item1 + &quot;,&quot; + source.Item2 + &quot;> : &quot; + conversation_tag);&#xA;&#x9;&#x9;&#x9;/* lock (lock_mpi) */ this.RootCommunicator.Send&lt;Tuple&lt;int,int,int>> (new Tuple&lt;int,int,int>(source.Item1, source.Item2, tag), 0, conversation_tag);&#xA;&#x9;&#x9;&#x9;Trace.WriteLineIf(this.TraceFlag==true, this.PeerRank + &quot;: 3 - BEGIN RECV FROM &lt;&quot; + source.Item1 + &quot;,&quot; + source.Item2 + &quot;> : &quot; + tag);&#xA;&#x9;&#x9;&#x9;MPI.ReceiveRequest root_request = this.RootCommunicator.ImmediateReceive&lt;byte[]>(0, tag);&#xA;&#x9;&#x9;&#x9;Trace.WriteLineIf(this.TraceFlag==true, this.PeerRank + &quot;: 4 - END RECV FROM &lt;&quot; + source.Item1 + &quot;,&quot; + source.Item2 + &quot;>&quot;);&#xA;&#x9;&#x9;&#x9;return br.ufc.mdcc.hpc.storm.binding.channel.Binding.ValueReceiveRequest&lt;T>.createRequest(root_request, source);&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;// Receive Array&#xA;&#xA;&#x9;&#x9;public void Receive&lt;T> (Tuple&lt;int,int> source, int tag, ref T[] values)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;br.ufc.mdcc.hpc.storm.binding.channel.Binding.CompletedStatus status;&#xA;&#x9;&#x9;&#x9;Receive(source, tag, ref values, out status);&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public void Receive&lt;T> (Tuple&lt;int,int> source, int tag, ref T[] values, out br.ufc.mdcc.hpc.storm.binding.channel.Binding.CompletedStatus status)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;int conversation_tag = takeNextConversationTag();&#xA;&#x9;&#x9;&#x9;/* lock (lock_mpi) */ this.RootCommunicator.Send&lt;Tuple&lt;int, int>>(new Tuple&lt;int, int>(AliencommunicatorOperation.RECEIVE_ARRAY, conversation_tag), 0, TAG_SEND_OPERATION);&#xA;&#x9;&#x9;&#x9;/* lock (lock_mpi) */ this.RootCommunicator.Send&lt;Tuple&lt;int,int,int>> (new Tuple&lt;int,int,int>(source.Item1, source.Item2, tag), 0, conversation_tag);&#xA;&#x9;&#x9;&#x9;MPI.CompletedStatus status_root;&#xA;&#x9;&#x9;&#x9;byte[] v;&#xA;&#x9;&#x9;&#x9;/* lock (lock_mpi) */ this.RootCommunicator.Receive&lt;byte[]> (0, tag, out v, out status_root);&#xA;&#x9;&#x9;&#x9;T[] values_ = (T[]) ByteArrayToObject(v);&#xA;&#xA;&#x9;&#x9;&#x9;// Copy the received values to the destination array (forcing original MPI semantics)&#xA;&#x9;&#x9;&#x9;int size = values.Length &lt;= values_.Length ? values.Length : values_.Length;&#xA;&#x9;&#x9;&#x9;for (int i=0; i&lt;size; i++)&#xA;&#x9;&#x9;&#x9;&#x9;values[i] = values_[i];&#xA;&#xA;&#x9;&#x9;&#x9;status = br.ufc.mdcc.hpc.storm.binding.channel.Binding.CompletedStatus.createStatus(status_root, source);&#xA;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public br.ufc.mdcc.hpc.storm.binding.channel.Binding.ReceiveRequest ImmediateReceive&lt;T> (Tuple&lt;int,int> source, int tag, T[] values)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;int conversation_tag = takeNextConversationTag();&#xA;&#x9;&#x9;&#x9;Trace.WriteLineIf(this.TraceFlag==true, this.PeerRank + &quot;: 1 - BEGIN RECV FROM &lt;&quot; + source.Item1 + &quot;,&quot; + source.Item2 + &quot;> : &quot; + TAG_SEND_OPERATION);&#xA;&#x9;&#x9;&#x9;/* lock (lock_mpi) */ this.RootCommunicator.Send&lt;Tuple&lt;int, int>>(new Tuple&lt;int, int>(AliencommunicatorOperation.RECEIVE_ARRAY, conversation_tag), 0, TAG_SEND_OPERATION);&#xA;&#x9;&#x9;&#x9;Trace.WriteLineIf(this.TraceFlag==true, this.PeerRank + &quot;: 2 - BEGIN RECV FROM &lt;&quot; + source.Item1 + &quot;,&quot; + source.Item2 + &quot;> : &quot; + conversation_tag);&#xA;&#x9;&#x9;&#x9;/* lock (lock_mpi) */ this.RootCommunicator.Send&lt;Tuple&lt;int,int,int>> (new Tuple&lt;int,int,int>(source.Item1, source.Item2, tag), 0, conversation_tag);&#xA;&#x9;&#x9;&#x9;Trace.WriteLineIf(this.TraceFlag==true, this.PeerRank + &quot;: 3 - BEGIN RECV FROM &lt;&quot; + source.Item1 + &quot;,&quot; + source.Item2 + &quot;> : &quot; + tag);&#xA;&#x9;&#x9;&#x9;MPI.ReceiveRequest root_request = this.RootCommunicator.ImmediateReceive&lt;byte[]>(0, tag);&#xA;&#x9;&#x9;&#x9;Trace.WriteLineIf(this.TraceFlag==true, this.PeerRank + &quot;: 4 - END RECV FROM &lt;&quot; + source.Item1 + &quot;,&quot; + source.Item2 + &quot;>&quot;);&#xA;&#x9;&#x9;&#x9;return br.ufc.mdcc.hpc.storm.binding.channel.Binding.ArrayReceiveRequest&lt;T>.createRequest (root_request, source, values);&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;// Probe&#xA;&#xA;&#x9;&#x9;public br.ufc.mdcc.hpc.storm.binding.channel.Binding.Status Probe (Tuple&lt;int,int> source, int tag)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;int conversation_tag = takeNextConversationTag();&#xA;&#x9;&#x9;&#x9;/* lock (lock_mpi) */ this.RootCommunicator.Send&lt;Tuple&lt;int, int>>(new Tuple&lt;int, int>(AliencommunicatorOperation.PROBE, conversation_tag), 0, TAG_SEND_OPERATION);&#xA;&#x9;&#x9;&#x9;throw new NotImplementedException ();&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public br.ufc.mdcc.hpc.storm.binding.channel.Binding.Status ImmediateProbe (Tuple&lt;int,int> source, int tag)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;int conversation_tag = takeNextConversationTag();&#xA;&#x9;&#x9;&#x9;/* lock (lock_mpi) */ this.RootCommunicator.Send&lt;Tuple&lt;int, int>>(new Tuple&lt;int, int>(AliencommunicatorOperation.PROBE, conversation_tag), 0, TAG_SEND_OPERATION);&#xA;&#x9;&#x9;&#x9;throw new NotImplementedException ();&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;#endregion&#xA;&#xA;&#x9;&#x9;#region Collective implementation&#xA;&#xA;&#xA;&#x9;&#x9;// All Gather&#xA;&#xA;&#x9;&#x9;public T[] Allgather&lt;T> (int facet, T value)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;T[] result = null;&#xA;&#x9;&#x9;&#x9;Allgather(facet, value, ref result);&#xA;&#x9;&#x9;&#x9;return result;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public void Allgather&lt;T> (int facet, T inValue, ref T[] outValues)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;int conversation_tag = takeNextConversationTag();&#xA;&#x9;&#x9;&#x9;/* lock (lock_mpi) */ this.RootCommunicator.Send&lt;Tuple&lt;int, int>>(new Tuple&lt;int, int>(AliencommunicatorOperation.ALL_GATHER, conversation_tag), 0, TAG_SEND_OPERATION);&#xA;&#x9;&#x9;&#x9;throw new NotImplementedException ();&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9; &#xA;&#x9;&#x9;// All Gather Flattened&#xA;&#xA;&#x9;&#x9;public void AllgatherFlattened&lt;T> (int facet, T[] inValues, int count, ref T[] outValues)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;int[] counts = new int[Size];&#xA;&#x9;&#x9;&#x9;for (int i = 0; i &lt; Size; i++)&#xA;&#x9;&#x9;&#x9;&#x9;counts[i] = count;&#xA;&#x9;&#x9;&#x9;AllgatherFlattened(facet, inValues, counts, ref outValues);&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public void AllgatherFlattened&lt;T> (int facet, T[] inValues, int[] counts, ref T[] outValues)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;int conversation_tag = takeNextConversationTag();&#xA;&#x9;&#x9;&#x9;/* lock (lock_mpi) */ this.RootCommunicator.Send&lt;Tuple&lt;int, int>>(new Tuple&lt;int, int>(AliencommunicatorOperation.ALL_GATHER_FLATTENED, conversation_tag), 0, TAG_SEND_OPERATION);&#xA;&#x9;&#x9;&#x9;throw new NotImplementedException ();&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;// All Reduce&#xA;&#xA;&#x9;&#x9;public T Allreduce&lt;T> (int facet, T value, ReductionOperation&lt;T> op)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;int conversation_tag = takeNextConversationTag();&#xA;&#x9;&#x9;&#x9;/* lock (lock_mpi) */ this.RootCommunicator.Send&lt;Tuple&lt;int, int>>(new Tuple&lt;int, int>(AliencommunicatorOperation.ALL_REDUCE, conversation_tag), 0, TAG_SEND_OPERATION + 0);&#xA;&#x9;&#x9;&#x9;throw new NotImplementedException ();&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;// All Reduce Array&#xA;&#xA;&#x9;&#x9;public T[] Allreduce&lt;T> (int facet, T[] values, ReductionOperation&lt;T> op)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;T[] result = null;&#xA;&#x9;&#x9;&#x9;Allreduce(facet, values, op, ref result);&#xA;&#x9;&#x9;&#x9;return result;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public void Allreduce&lt;T> (int facet, T[] inValues, ReductionOperation&lt;T> op, ref T[] outValues)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;int conversation_tag = takeNextConversationTag();&#xA;&#x9;&#x9;&#x9;/* lock (lock_mpi) */ this.RootCommunicator.Send&lt;Tuple&lt;int, int>>(new Tuple&lt;int, int>(AliencommunicatorOperation.ALL_REDUCE_ARRAY, conversation_tag), 0, TAG_SEND_OPERATION + 0);&#xA;&#x9;&#x9;&#x9;throw new NotImplementedException ();&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;// AllToAll&#xA;&#xA;&#x9;&#x9;public T[] Alltoall&lt;T> (int facet, T[] values)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;T[] result = null;&#xA;&#x9;&#x9;&#x9;Alltoall(facet, values, ref result);&#xA;&#x9;&#x9;&#x9;return result;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public void Alltoall&lt;T> (int facet, T[] inValues, ref T[] outValues)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;int conversation_tag = takeNextConversationTag();&#xA;&#x9;&#x9;&#x9;/* lock (lock_mpi) */ this.RootCommunicator.Send&lt;Tuple&lt;int, int>>(new Tuple&lt;int, int>(AliencommunicatorOperation.ALL_TO_ALL, conversation_tag), 0, TAG_SEND_OPERATION);&#xA;&#x9;&#x9;&#x9;throw new NotImplementedException ();&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;// All-to-All Flattened&#xA;&#xA;&#x9;&#x9;public void AlltoallFlattened&lt;T> (int facet, T[] inValues, int[] sendCounts, int[] recvCounts, ref T[] outValues)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;int conversation_tag = takeNextConversationTag();&#xA;&#x9;&#x9;&#x9;/* lock (lock_mpi) */ this.RootCommunicator.Send&lt;Tuple&lt;int, int>>(new Tuple&lt;int, int>(AliencommunicatorOperation.ALL_TO_ALL_FLATTENED, conversation_tag), 0, TAG_SEND_OPERATION + 0);&#xA;&#x9;&#x9;&#x9;throw new NotImplementedException ();&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;// Reduce-Scatter&#xA;&#xA;&#x9;&#x9;public T[] ReduceScatter&lt;T> (int facet, T[] values, ReductionOperation&lt;T> op, int[] counts)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;T[] result = null;&#xA;&#x9;&#x9;&#x9;ReduceScatter(facet, values, op, counts, ref result);&#xA;&#x9;&#x9;&#x9;return result;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public void ReduceScatter&lt;T> (int facet, T[] inValues, ReductionOperation&lt;T> op, int[] counts, ref T[] outValues)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;int conversation_tag = takeNextConversationTag();&#xA;&#x9;&#x9;&#x9;/* lock (lock_mpi) */ this.RootCommunicator.Send&lt;Tuple&lt;int, int>>(new Tuple&lt;int, int>(AliencommunicatorOperation.REDUCE_SCATTER, conversation_tag), 0, TAG_SEND_OPERATION + 0);&#xA;&#x9;&#x9;&#x9;throw new NotImplementedException ();&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;// BROADCAST&#xA;&#xA;&#x9;&#x9;public void Broadcast&lt;T> (int facet, ref T value, int root)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;int conversation_tag = takeNextConversationTag();&#xA;&#x9;&#x9;&#x9;/* lock (lock_mpi) */ this.RootCommunicator.Send&lt;Tuple&lt;int, int>>(new Tuple&lt;int, int>(AliencommunicatorOperation.BROADCAST, conversation_tag), 0, TAG_SEND_OPERATION + 0);&#xA;&#x9;&#x9;&#x9;throw new NotImplementedException ();&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public void Broadcast&lt;T> (int facet, ref T[] values, int root)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;int conversation_tag = takeNextConversationTag();&#xA;&#x9;&#x9;&#x9;/* lock (lock_mpi) */ this.RootCommunicator.Send&lt;Tuple&lt;int, int>>(new Tuple&lt;int, int>(AliencommunicatorOperation.BROADCAST_ARRAY, conversation_tag), 0, TAG_SEND_OPERATION);&#xA;&#x9;&#x9;&#x9;throw new NotImplementedException ();&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;// Scatter&#xA;&#xA;&#x9;&#x9;public void Scatter&lt;T> (int facet, T[] values)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;int conversation_tag = takeNextConversationTag();&#xA;&#x9;&#x9;&#x9;/* lock (lock_mpi) */ this.RootCommunicator.Send&lt;Tuple&lt;int, int>>(new Tuple&lt;int, int>(AliencommunicatorOperation.SCATTER, conversation_tag), 0, TAG_SEND_OPERATION);&#xA;&#x9;&#x9;&#x9;throw new NotImplementedException ();&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public T Scatter&lt;T> (int facet, int root)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;int conversation_tag = takeNextConversationTag();&#xA;&#x9;&#x9;&#x9;/* lock (lock_mpi) */ this.RootCommunicator.Send&lt;Tuple&lt;int, int>>(new Tuple&lt;int, int>(AliencommunicatorOperation.SCATTER, conversation_tag), 0, TAG_SEND_OPERATION);&#xA;&#x9;&#x9;&#x9;throw new NotImplementedException ();&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public void Scatter&lt;T> (int facet)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;int conversation_tag = takeNextConversationTag();&#xA;&#x9;&#x9;&#x9;/* lock (lock_mpi) */ this.RootCommunicator.Send&lt;Tuple&lt;int, int>>(new Tuple&lt;int, int>(AliencommunicatorOperation.SCATTER, conversation_tag), 0, TAG_SEND_OPERATION);&#xA;&#x9;&#x9;&#x9;throw new NotImplementedException ();&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;// Scatter from Flattened&#xA;&#xA;&#x9;&#x9;public void ScatterFromFlattened&lt;T> (int facet, T[] inValues, int count)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;T[] temp = new T[0];&#xA;&#x9;&#x9;&#x9;ScatterFromFlattened&lt;T>(facet, inValues, count, Root, ref temp);&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public void ScatterFromFlattened&lt;T> (int facet, T[] inValues, int[] counts)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;T[] temp = new T[0];&#xA;&#x9;&#x9;&#x9;ScatterFromFlattened&lt;T>(facet, inValues, counts, Root, ref temp);&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public void ScatterFromFlattened&lt;T> (int facet, int count, int root, ref T[] outValues)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;ScatterFromFlattened&lt;T>(facet, null, count, root, ref outValues);&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public void ScatterFromFlattened&lt;T> (int facet, int[] counts, int root, ref T[] outValues)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;ScatterFromFlattened&lt;T>(facet, null, counts, root, ref outValues);&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public void ScatterFromFlattened&lt;T> (int facet)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;T[] temp = new T[0];&#xA;&#x9;&#x9;&#x9;ScatterFromFlattened&lt;T>(facet, null, new int[0], Null, ref temp);&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public void ScatterFromFlattened&lt;T> (int facet, T[] inValues, int count, int root, ref T[] outValues)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;int[] counts = new int[Size];&#xA;&#x9;&#x9;&#x9;for (int i = 0; i &lt; Size; i++)&#xA;&#x9;&#x9;&#x9;&#x9;counts[i] = count;&#xA;&#x9;&#x9;&#x9;ScatterFromFlattened&lt;T>(facet, inValues, counts, root, ref outValues);&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public void ScatterFromFlattened&lt;T> (int facet, T[] inValues, int[] counts, int root, ref T[] outValues)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;int conversation_tag = takeNextConversationTag();&#xA;&#x9;&#x9;&#x9;/* lock (lock_mpi) */ this.RootCommunicator.Send&lt;Tuple&lt;int, int>>(new Tuple&lt;int, int>(AliencommunicatorOperation.SCATTER_FROM_FLATTENED, conversation_tag), 0, TAG_SEND_OPERATION + 0);&#xA;&#x9;&#x9;&#x9;throw new NotImplementedException ();&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;// Gather&#xA;&#xA;&#x9;&#x9;public T[] Gather&lt;T> (int facet, T value, int root)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;T[] result = null;&#xA;&#x9;&#x9;&#x9;Gather(facet, value, root, ref result);&#xA;&#x9;&#x9;&#x9;return result;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public T[] Gather&lt;T> (int facet, int root)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;T value = default(T);&#xA;&#x9;&#x9;&#x9;T[] result = null;&#xA;&#x9;&#x9;&#x9;Gather(facet, value, Root, ref result);&#xA;&#x9;&#x9;&#x9;return result;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public void Gather&lt;T> (int facet)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;T value = default(T);&#xA;&#x9;&#x9;&#x9;T[] result = null;&#xA;&#x9;&#x9;&#x9;Gather(facet, value, Null, ref result);&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public void Gather&lt;T> (int facet, T inValue, int root, ref T[] outValues)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;Gather_impl&lt;T>(facet, (root == Root), RemoteSize, inValue, root, ref outValues);&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;internal void Gather_impl&lt;T>(int facet, bool isRoot, int size, T inValue, int root, ref T[] outValues)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;int conversation_tag = takeNextConversationTag();&#xA;&#x9;&#x9;&#x9;/* lock (lock_mpi) */ this.RootCommunicator.Send&lt;Tuple&lt;int, int>>(new Tuple&lt;int, int>(AliencommunicatorOperation.GATHER, conversation_tag), 0, TAG_SEND_OPERATION + 0);&#xA;&#x9;&#x9;&#x9;throw new NotImplementedException ();&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;// Gather Flattened&#xA;&#xA;&#x9;&#x9;public void GatherFlattened&lt;T> (int facet, int count, ref T[] outValues)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;if (outValues == null || outValues.Length != count * RemoteSize)&#xA;&#x9;&#x9;&#x9;&#x9;outValues = new T[count * RemoteSize];&#xA;&#xA;&#xA;&#x9;&#x9;&#x9;int[] counts = new int[Size];&#xA;&#x9;&#x9;&#x9;for (int i = 0; i &lt; Size; i++)&#xA;&#x9;&#x9;&#x9;&#x9;counts[i] = count;&#xA;&#xA;&#x9;&#x9;&#x9;GatherFlattened_impl&lt;T>(facet, true, RemoteSize, new T[0], counts, Root, ref outValues);&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public T[] GatherFlattened&lt;T> (int facet, int count)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;T[] outValues = new T[RemoteSize * count];&#xA;&#xA;&#x9;&#x9;&#x9;int[] counts = new int[Size];&#xA;&#x9;&#x9;&#x9;for (int i = 0; i &lt; Size; i++)&#xA;&#x9;&#x9;&#x9;&#x9;counts[i] = count;&#xA;&#xA;&#x9;&#x9;&#x9;GatherFlattened_impl&lt;T>(facet, true, RemoteSize, new T[0], counts, Root, ref outValues);&#xA;&#xA;&#x9;&#x9;&#x9;return outValues;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public void GatherFlattened&lt;T> (int facet, T[] inValues, int root)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;T[] temp = new T[0];&#xA;&#x9;&#x9;&#x9;GatherFlattened_impl&lt;T>(facet, false, Size, inValues, new int[0], root, ref temp);&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public void GatherFlattened&lt;T> (int facet)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;T[] temp = new T[0];&#xA;&#x9;&#x9;&#x9;GatherFlattened_impl&lt;T>(facet, false, RemoteSize, new T[0], new int[0], Null, ref temp);&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public void GatherFlattened&lt;T> (int facet, int[] counts, ref T[] outValues)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;int totalCounts = 0;&#xA;&#x9;&#x9;&#x9;for (int i = 0; i &lt; counts.Length; i++)&#xA;&#x9;&#x9;&#x9;&#x9;totalCounts += counts[i];&#xA;&#xA;&#x9;&#x9;&#x9;if (outValues == null || outValues.Length != totalCounts * RemoteSize)&#xA;&#x9;&#x9;&#x9;&#x9;outValues = new T[totalCounts * RemoteSize];&#xA;&#xA;&#x9;&#x9;&#x9;GatherFlattened_impl&lt;T>(facet, true, RemoteSize, new T[0], counts, Root, ref outValues);&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public T[] GatherFlattened&lt;T> (int facet, int[] counts)&#xA;&#x9;&#x9;{ &#xA;&#x9;&#x9;&#x9;int totalCounts = 0;&#xA;&#x9;&#x9;&#x9;for (int i = 0; i &lt; counts.Length; i++)&#xA;&#x9;&#x9;&#x9;&#x9;totalCounts += counts[i];&#xA;&#x9;&#x9;&#x9;T[] outValues = new T[totalCounts];&#xA;&#xA;&#x9;&#x9;&#x9;GatherFlattened_impl&lt;T>(facet, true, RemoteSize, new T[0], counts, Root, ref outValues);&#xA;&#xA;&#x9;&#x9;&#x9;return outValues;&#xA;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;internal void GatherFlattened_impl&lt;T>(int facet, bool isRoot, int size, T[] inValues, int[] counts, int root, ref T[] outValues)&#xA;&#x9;&#x9;{ &#xA;&#x9;&#x9;&#x9;int conversation_tag = takeNextConversationTag();&#xA;&#x9;&#x9;&#x9;/* lock (lock_mpi) */ this.RootCommunicator.Send&lt;Tuple&lt;int, int>>(new Tuple&lt;int, int>(AliencommunicatorOperation.GATHER_FLATTENED, conversation_tag), 0, TAG_SEND_OPERATION + 0);&#xA;&#x9;&#x9;&#x9;throw new NotImplementedException ();&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;// Reduce&#xA;&#xA;&#x9;&#x9;public T Reduce&lt;T> (int facet, T value, ReductionOperation&lt;T> op, int root)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;return Reduce_impl&lt;T>(facet, (root == Root), RemoteSize, value, op, root);&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;internal T Reduce_impl&lt;T>(int facet, bool isRoot, int size, T value, ReductionOperation&lt;T> op, int root)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;int conversation_tag = takeNextConversationTag();&#xA;&#x9;&#x9;&#x9;/* lock (lock_mpi) */ this.RootCommunicator.Send&lt;Tuple&lt;int, int>>(new Tuple&lt;int, int>(AliencommunicatorOperation.REDUCE, conversation_tag), 0, TAG_SEND_OPERATION + 0);&#xA;&#x9;&#x9;&#x9;throw new NotImplementedException ();&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;// Reduce Array&#xA;&#xA;&#x9;&#x9;public T[] Reduce&lt;T> (int facet, T[] values, ReductionOperation&lt;T> op, int root)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;T[] result = null;&#xA;&#x9;&#x9;&#x9;Reduce(facet, values, op, root, ref result);&#xA;&#x9;&#x9;&#x9;return result;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public void Reduce&lt;T> (int facet, T[] inValues, ReductionOperation&lt;T> op, int root, ref T[] outValues)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;int conversation_tag = takeNextConversationTag();&#xA;&#x9;&#x9;&#x9;/* lock (lock_mpi) */ this.RootCommunicator.Send&lt;Tuple&lt;int, int>>(new Tuple&lt;int, int>(AliencommunicatorOperation.REDUCE_ARRAY, conversation_tag), 0, TAG_SEND_OPERATION + 0);&#xA;&#x9;&#x9;&#x9;throw new NotImplementedException ();&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;#endregion&#xA;&#xA;&#x9;&#x9;/*&#xA;&#x9;&#x9;public void SendReceive&lt;T> (T inValue, int dest, int tag, out T outValue)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;CompletedStatus status;&#xA;&#x9;&#x9;&#x9;SendReceive(inValue, dest, tag, dest, tag, out outValue, out status);&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public void SendReceive&lt;T> (T inValue, int dest, int sendTag, int source, int recvTag, out T outValue)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;CompletedStatus status;&#xA;&#x9;&#x9;&#x9;SendReceive(inValue, dest, sendTag, source, recvTag, out outValue, out status);&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public void SendReceive&lt;T> (T inValue, int dest, int sendTag, int source, int recvTag, out T outValue, out CompletedStatus status)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;throw new NotImplementedException ();&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public void SendReceive&lt;T> (T[] inValues, int dest, int tag, ref T[] outValues)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;CompletedStatus status;&#xA;&#x9;&#x9;&#x9;SendReceive(inValues, dest, tag, dest, tag, ref outValues, out status);&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public void SendReceive&lt;T> (T[] inValues, int dest, int sendTag, int source, int recvTag, ref T[] outValues)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;CompletedStatus status;&#xA;&#x9;&#x9;&#x9;SendReceive(inValues, dest, sendTag, source, recvTag, ref outValues, out status);&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public void SendReceive&lt;T> (T[] inValues, int dest, int sendTag, int source, int recvTag, ref T[] outValues, out CompletedStatus status)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;throw new NotImplementedException ();&#xA;&#x9;&#x9;}&#xA;       */&#xA;&#xA;&#x9;&#x9;// Convert an object to a byte array&#xA;&#x9;&#x9;private static byte[] ObjectToByteArray(Object obj)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;if(obj == null)&#xA;&#x9;&#x9;&#x9;&#x9;return null;&#xA;&#x9;&#x9;&#x9;BinaryFormatter bf = new BinaryFormatter();&#xA;&#x9;&#x9;&#x9;MemoryStream ms = new MemoryStream();&#xA;&#x9;&#x9;&#x9;bf.Serialize(ms, obj);&#xA;&#x9;&#x9;&#x9;return ms.ToArray();&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;private static Object ByteArrayToObject(byte[] arrBytes)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;MemoryStream memStream = new MemoryStream();&#xA;&#x9;&#x9;&#x9;BinaryFormatter binForm = new BinaryFormatter();&#xA;&#x9;&#x9;&#x9;memStream.Write(arrBytes, 0, arrBytes.Length);&#xA;&#x9;&#x9;&#x9;memStream.Seek(0, SeekOrigin.Begin);&#xA;&#x9;&#x9;&#x9;Object obj = (Object) binForm.Deserialize(memStream);&#xA;&#x9;&#x9;&#x9;return obj;&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#xA;}&#xA;" name="IChannelImpl.cs" srcType="user" uri="br.ufc.mdcc.hpc.storm.binding.channel.impl.BindingImpl/bin/1.0.0.0/IChannelImpl.dll" versionId="1.0.0.0">
          <dependency>%WORKSPACE/br.ufc.mdcc.hpc.storm.binding.channel.impl.BindingImpl/bin/1.0.0.0/BaseIChannelImpl.dll</dependency>
          <dependency>br.ufc.mdcc.hpc.storm.binding.channel.Binding/bin/1.0.0.0/IChannel.dll</dependency>
          <externalDependency>MPI</externalDependency>
        </file>
      </sources>
      <visualDescription h="40" w="179" x="227" y="489">
        <color b="144" g="238" r="144"/>
      </visualDescription>
      <externalReferences>MPI</externalReferences>
    </interface>
    <unit facet="0" iRef="IChannelRootImpl" multiple="false" private="false" replica="0" uRef="root" visibleInterface="true">
      <super cRef="base" uRef="root"/>
      <visualDescription h="40" w="146" x="175" y="145"/>
    </unit>
    <unit facet="0" iRef="IChannelImpl" multiple="true" private="false" replica="0" uRef="peer" visibleInterface="true">
      <super cRef="base" uRef="peer"/>
      <visualDescription h="47" w="133" x="229" y="366"/>
    </unit>
  </componentInfo>
</component:component>